resid(model1)
cov(x,y)
var(x)
plot(y~x)
cov(x,y)
var(x)
abline(model1)
y <-c(4,3,5,7,9,10000000)
model1 <- (lm(y~x))
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1)
y <-c(4,3,5,7,9,10000000)
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
y <-c(4,3,5,7,9,4)
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
model1 <- lm(log(y)~log(x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1,1)
y <-c(4,3,5,7,9,4,1000000)
model1 <- lm(log(y)~log(x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1,1)
y <-c(4,3,5,7,9,4,5)
model1 <- lm(y~x)
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
rm(list=ls())
require(WebPower)
install.package("webpower")
require(WebPower)
install.package("WebPower")
require(WebPower)
Install.Package("WebPower")
require(WebPower)
install.packages("WebPower")
require(WebPower)
require(WebPower)
?WebPower
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
plot(hist(y, breaks=10))
mean(y)
sd(y)
segments(x0=(mean(y)), y0=(0), x1=(mean(y)), y1=40, lty=1, col="blue")
rm(list=ls())
require(WebPower)
?webpower
?WebPower
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
length(x)
plot(hist(y, breaks=10))
mean(y)
sd(y)
segments(x0=(mean(y)), y0=(0), x1=(mean(y)), y1=40, lty=1, col="blue")
# and now 0.25 sd left of the mean (because females are larger)
segments(x0=(mean(y)+0.25*sd(y)), y0=(0), x1=(mean(y)+0.25*sd(y)), y1=40, lty
=1, col="red")
?wp.t
wp.t(d=0.25, power=0.8, type="two.sample", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
res.1
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
res.1
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample
", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample", alternative="two.sided")
res.1
wp.t(d=0.25, power=0.8, type="two.sample", alternative="two.sided") #default two sided test needs to be run because not enough data
plot(res.1, xvar='n1', yvar='power')
plot(res.1, xvar='n1', yvar='power')
plot(res.1, xvar='n1', yvar='n2')
plot(res.1, xvar='n1', yvar='n2')
plot(res.1)
rm(list=ls())
x<-seq(from = -5, to = 5, by = 1)
x
## [1] 3
x[[length(x)]]
x<-seq(from = -5, to = 5, by = 1)
x
a<-2 #intercept
b<-1 #slope
y<-a+b*x
plot(x,y)
segments(0,-10,0,10, lty=3) #add axes
segments(-10,0,10,0,lty=3)
plot(x,y)
segments(0,-10,0,10, lty=3) #add axes
segments(-10,0,10,0,lty=3)
?abline
plot(x,y, col="white")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
abline(a = 2, b=1)
plot(x,y, col="green")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
plot(x,y, col="black")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
abline(a = 2, b=1)
points(4,0, col="red", pch=19)
points(-2,6, col="green", pch=9)
points(x,y, pch=c(1,2,3,4,5,6,7,8,9,10,11))
y<-x^2
plot(x,y)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
segments(0,-40,0,30, lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,20,30,0,lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(-30,0,30,0,lty=3)
segments(0,-30,0,30, lty=3)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
segments(0,-5,0,30, lty=3)
segments(0,-5,0,5, lty=3)
segments(0,-5,0,3, lty=3)
segments(0,-3,0,3, lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-3,0,3, lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-3,0,3, lty=3)
segments(0,-30,0,30, lty=3)
y<-x^2
plot(x,y)
segments(-3,0,3,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
#give linear function intercept of a-2
x<-seq(from = -5, to = 5, by = 0.1)
a<- -2
y<-a+x^2
plot(x,y)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
plot(x,y)
a<- -2
b<-3
y<-a+b*x^2
points(x,y, pch=19, col="red")
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
y<-a+b*x^2 #gave the curve a higher slope
points(x,y, pch=19, col="red")
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
plot(x,y)
a<- -2
b1<- 10
b2<-3
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(-100,0,100,0,lty=3)
plot(x,y)
a<- 1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(-100,0,100,0,lty=3)
plot(x,y)
a<- 1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
x<-seq(from = -100, to = 100, by = 1)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
text(highest_x, highest_y, labels=paste("Max y =", round(highest_y, 2)), pos=3)
#find highest y point in equation
x<-seq(from = -100, to = 100, by = 1)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
text(highest_x, highest_y, labels=paste("Max y =", round(highest_y, 2)), pos=3) # pos=3 places the text above the point for better visibility
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
#Local paralellisation
#run tasks in parallel for greater speed/efficiency
n <- 10000 #number of observations
data <- data.frane(
ID = sample(1:10, n, replace = TRUE), # ID column to define 10 groups
Y = rnorm(n), #creates a vector of 10000 random values from normal standard dist (mean=0,sd=1)
x = rnorm(n)
)
data <- data.frame(
ID = sample(1:10, n, replace = TRUE), # ID column to define 10 groups
Y = rnorm(n), #creates a vector of 10000 random values from normal standard dist (mean=0,sd=1)
x = rnorm(n)
)
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
View(data_groups)
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
model <- lm(y ~ X, data = group_data)
coef_df <- as.data.frame(t(coef(model)))
coef_df$ID <- unique(group_data$ID)  # Add ID for reference
return(coef_df)
}
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting y using X
model <- lm(y ~ X, data = group_data)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting y using X
model <- lm(y ~ X, data = data_groups)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting Y using x
model <- lm(Y ~ x, data = group_data)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
# Now, run the parallel code to fit models for each group
library(parallel)
num_cores <- detectCores() - 1  # Use all cores but one
# Use mclapply to run the fit_model function on each subset of the data
results <- mclapply(data_groups, fit_model, mc.cores = num_cores)
# Bind all the results into one data frame
final_results <- bind_rows(results)
print(final_results)
setwd("~/Documents/CMEECourseWork/Maths-for-ecology-and-evolution/code")
moby <- read.csv('../data/words_moby_dick.csv')
View(moby)
ordered_wordlabel <- moby[order(moby$word_label)]
ordered_wordlabel <- moby[order(moby$word_label)]
ordered_wordlabel <- moby[order(moby$word_label), ]
write.csv(ordered_wordlabel, "../data/ordered_moby.csv", row.names= FALSE)
moby <- read.csv('../data/ordered_moby.csv')
moby <- read.csv('../data/ordered_moby.csv')
View(moby)
View(moby)
loglog_worldlabel <- moby$word_label
loglog_occurances <- moby$occurences
loglog_worldlabel <- log(log(moby$word_label))
loglog_occurances <- log(log(moby$occurences))
plot(loglog_occurances, loglog_worldlabel)
plot(loglog_worldlabel, loglog_occurances)
plot(loglog_worldlabel, loglog_occurances)
model <- lm(loglog_occurances ~ loglog_worldlabel)
model <- lm(loglog_occurances ~ loglog_worldlabel)
log_worldlabel <- log(moby$word_label))
log_occurances <- log(moby$occurences))
log_worldlabel <- log(moby$word_label))
log_occurances <- log(moby$occurences))
log_worldlabel <- log(moby$word_label)
log_occurances <- log(moby$occurences)
plot(loglog_worldlabel, loglog_occurances)
model <- lm(log_occurances ~ log_worldlabel)
log_worldlabel <- log(moby$word_label)
log_occurances <- log(moby$occurences)
plot(log_worldlabel, log_occurances)
model <- lm(log_occurances ~ log_worldlabel)
model <- lm(log_occurances ~ log_worldlabel)
summary(model)
abline(model, col = "red")
sim_gene_drive()
sim_gene_drive<-function(q0=0.05, d=0.6, t=10, N0=500, R0=2, M=500)
{
# SOME CHECKS ON THE INPUT PARAMETERS (OPTIONAL)
if (q0<=0 || q0>0.5)
{stop('PLEASE MAKE SURE THAT 0<q0<0.5!')}
if (d<=0.5 || d>=1)
{stop('PLEASE MAKE SURE THAT 0.5<d<1!')}
# INNER FUNCTIONS. THESE INNER FUNCTIONS ARE ONLY VISIBLE WITHIN sim_gene_drive()
# 1) THE BEVERTON-HOLT MODEL. ceiling() TO ROUND UP. RETURN NEW POPULATION SIZE.
bh<-function(N, R0, M)
{return(ceiling(R0*N/(1+N/M)))}
# 2) RETURN THE COUNTS FOR 00, 01, 11 GENOTYPES
count_genotype <- function(x) {
# Sum the values in each column of x (each mosquito's two alleles)
temp <- apply(x, 2, sum)
# Count the number of mosquitoes with each genotype:
# - sum(temp == 0): Count of individuals with genotype 00 (wild type)
# - sum(temp == 1): Count of individuals with genotype 01 (heterozygous)
# - sum(temp == 2): Count of individuals with genotype 11 (homozygous transgenic)
return(c(sum(temp == 0), sum(temp == 1), sum(temp == 2)))
}
# INITIALISE
# CREATE A LIST TO STORE ALL THE ALLEIC CONFIGURATIONS
population<-list()
length(population)<-(t+1)
for (i in 1:(t+1))
{names(population)[i]<-paste(c('generation', i-1), collapse='')}
# ALSO CREATE TWO VECTORS TO STORE THE POPULATION SIZES AND THE FREQ OF TG OVER TIME
population.size<-rep(NA, t+1)
TG.freq<-rep(NA, t+1)
# INITIAL POPULATION SIZE AND TG FREQ
population.size[1]<-N0
TG.freq[1]<-q0
# WE WILL RELEASE k TRANSGENIC MOSQUITOES, WHO CARRY 01 HETEROZYGOTE
# WHICH MEANS AT GEN 0 THERE ARE (N0-k) WT MOSQUITOES WITH 00 HOMOZYGOTES
k<-ceiling(2*N0*q0)
population[[1]]<-cbind(matrix(c(0,0), nr=2, nc=N0-k), matrix(c(0,1), nr=2, nc=k))
# CALCULATE THE GENOTYPE COUNTS (WE'LL REUSE THE VECTOR genotype IN THE FOR LOOP)
genotype<-count_genotype(population[[1]])
# PROPAGATION
for (i in 1:t)
{
# CALCULATE THE NEW POPULATION SIZE. ONLY genotype[1]+genotype[2] WILL SURVIVE TILL ADULTHOOD
population.size[i+1]<-bh(genotype[1]+genotype[2], R0, M)
# EARLY EXIT CONDITION 1, IF POPULATION SIZE DROP TO 1
if (population.size[i+1]<=1)
{
print(paste(c('Oops! The population crashed after generation ', i-1), collapse=''))
return(list(population=population[1:i], population.size=population.size[1:i],
TG.freq=TG.freq[1:i]))
}
# EARLY EXIT CONDITION 2, IF THERE IS NO MORE TG ALLELE
if (genotype[2]+genotype[3]==0)
{
print(paste(c('Oops! TG allele went extinct at generation ', i-1), collapse=''))
return(list(population=population[1:i], population.size=population.size[1:i],
TG.freq=TG.freq[1:i]))
}
# CALCULATE TG GAMETIC FREQ
TG.gametic.freq<-d*genotype[2]/(genotype[1]+genotype[2])
# SAMPLE THE NEXT GENERATION
population[[i+1]]<-matrix(sample(0:1, size=2*population.size[i+1],
prob=c(1-TG.gametic.freq, TG.gametic.freq), replace=T), nr=2)
# CALCULATE NEW GENOTYPE COUNTS AND TG FREQ
genotype<-count_genotype(population[[i+1]])
TG.freq[i+1]<-(0.5*genotype[2]+genotype[3])/population.size[i+1]
}
# OUTPUTS. RETURN A BIG LIST OF EVERYTHING
return(list(population=population, population.size=population.size, TG.freq=TG.freq))
}
sim_gene_drive(q0=0.05, d=0.6, t=4)
