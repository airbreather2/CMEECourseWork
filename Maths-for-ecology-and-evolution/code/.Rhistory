summary(model1)
anova(model1)
resid(model1)
cov(x,y)
var(x)
plot(y~x)
cov(x,y)
var(x)
abline(model1)
y <-c(4,3,5,7,9,10000000)
model1 <- (lm(y~x))
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1)
y <-c(4,3,5,7,9,10000000)
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
y <-c(4,3,5,7,9,4)
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
model1 <- lm(log(y)~log(x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1,1)
y <-c(4,3,5,7,9,4,1000000)
model1 <- lm(log(y)~log(x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1,1)
y <-c(4,3,5,7,9,4,5)
model1 <- lm(y~x)
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
rm(list=ls())
require(WebPower)
install.package("webpower")
require(WebPower)
install.package("WebPower")
require(WebPower)
Install.Package("WebPower")
require(WebPower)
install.packages("WebPower")
require(WebPower)
require(WebPower)
?WebPower
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
plot(hist(y, breaks=10))
mean(y)
sd(y)
segments(x0=(mean(y)), y0=(0), x1=(mean(y)), y1=40, lty=1, col="blue")
rm(list=ls())
require(WebPower)
?webpower
?WebPower
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
length(x)
plot(hist(y, breaks=10))
mean(y)
sd(y)
segments(x0=(mean(y)), y0=(0), x1=(mean(y)), y1=40, lty=1, col="blue")
# and now 0.25 sd left of the mean (because females are larger)
segments(x0=(mean(y)+0.25*sd(y)), y0=(0), x1=(mean(y)+0.25*sd(y)), y1=40, lty
=1, col="red")
?wp.t
wp.t(d=0.25, power=0.8, type="two.sample", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
res.1
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
res.1
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample
", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample", alternative="two.sided")
res.1
wp.t(d=0.25, power=0.8, type="two.sample", alternative="two.sided") #default two sided test needs to be run because not enough data
plot(res.1, xvar='n1', yvar='power')
plot(res.1, xvar='n1', yvar='power')
plot(res.1, xvar='n1', yvar='n2')
plot(res.1, xvar='n1', yvar='n2')
plot(res.1)
rm(list=ls())
x<-seq(from = -5, to = 5, by = 1)
x
## [1] 3
x[[length(x)]]
x<-seq(from = -5, to = 5, by = 1)
x
a<-2 #intercept
b<-1 #slope
y<-a+b*x
plot(x,y)
segments(0,-10,0,10, lty=3) #add axes
segments(-10,0,10,0,lty=3)
plot(x,y)
segments(0,-10,0,10, lty=3) #add axes
segments(-10,0,10,0,lty=3)
?abline
plot(x,y, col="white")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
abline(a = 2, b=1)
plot(x,y, col="green")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
plot(x,y, col="black")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
abline(a = 2, b=1)
points(4,0, col="red", pch=19)
points(-2,6, col="green", pch=9)
points(x,y, pch=c(1,2,3,4,5,6,7,8,9,10,11))
y<-x^2
plot(x,y)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
segments(0,-40,0,30, lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,20,30,0,lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(-30,0,30,0,lty=3)
segments(0,-30,0,30, lty=3)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
segments(0,-5,0,30, lty=3)
segments(0,-5,0,5, lty=3)
segments(0,-5,0,3, lty=3)
segments(0,-3,0,3, lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-3,0,3, lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-3,0,3, lty=3)
segments(0,-30,0,30, lty=3)
y<-x^2
plot(x,y)
segments(-3,0,3,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
#give linear function intercept of a-2
x<-seq(from = -5, to = 5, by = 0.1)
a<- -2
y<-a+x^2
plot(x,y)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
plot(x,y)
a<- -2
b<-3
y<-a+b*x^2
points(x,y, pch=19, col="red")
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
y<-a+b*x^2 #gave the curve a higher slope
points(x,y, pch=19, col="red")
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
plot(x,y)
a<- -2
b1<- 10
b2<-3
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(-100,0,100,0,lty=3)
plot(x,y)
a<- 1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(-100,0,100,0,lty=3)
plot(x,y)
a<- 1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
x<-seq(from = -100, to = 100, by = 1)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
text(highest_x, highest_y, labels=paste("Max y =", round(highest_y, 2)), pos=3)
#find highest y point in equation
x<-seq(from = -100, to = 100, by = 1)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
text(highest_x, highest_y, labels=paste("Max y =", round(highest_y, 2)), pos=3) # pos=3 places the text above the point for better visibility
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
#Local paralellisation
#run tasks in parallel for greater speed/efficiency
n <- 10000 #number of observations
data <- data.frane(
ID = sample(1:10, n, replace = TRUE), # ID column to define 10 groups
Y = rnorm(n), #creates a vector of 10000 random values from normal standard dist (mean=0,sd=1)
x = rnorm(n)
)
data <- data.frame(
ID = sample(1:10, n, replace = TRUE), # ID column to define 10 groups
Y = rnorm(n), #creates a vector of 10000 random values from normal standard dist (mean=0,sd=1)
x = rnorm(n)
)
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
View(data_groups)
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
model <- lm(y ~ X, data = group_data)
coef_df <- as.data.frame(t(coef(model)))
coef_df$ID <- unique(group_data$ID)  # Add ID for reference
return(coef_df)
}
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting y using X
model <- lm(y ~ X, data = group_data)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting y using X
model <- lm(y ~ X, data = data_groups)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting Y using x
model <- lm(Y ~ x, data = group_data)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
# Now, run the parallel code to fit models for each group
library(parallel)
num_cores <- detectCores() - 1  # Use all cores but one
# Use mclapply to run the fit_model function on each subset of the data
results <- mclapply(data_groups, fit_model, mc.cores = num_cores)
# Bind all the results into one data frame
final_results <- bind_rows(results)
print(final_results)
setwd("~/Documents/Maths-for-ecology-and-evolution/code")
#question 2
x <- seq(0, 100, by = 0.5)
y <- 1.48*x
plot(x,y)
#question 2
x <- seq(0, 100, by = 0.5)
y <- x^1.84
plot(x,y)
b <- seq(0, 100, by = 0.5)
a <- b^-0.49
plot(b,a,xlab = "leaf thickness", ylab = "spongy mesophyll volume")
#question 4
x <- seq(-2 * pi, 2 * pi, length.out = 100)
y<- sin(x)
plot(x,y)
#question 4
x <- seq(-2 * pi, 2 * pi, length.out = 1000)
y<- sin(x)
plot(x,y)
y< - cos(x)
plot(x,y)
plot(x,y)
y<- sin(x)
plot(x,y)
y< - cos(x)
plot(x,y)
y< - cos(x)
plot(x,y)
y<- sin(x)
plot(x,y)
y< - cos(x)
plot(x,y)
y< - cos(x)
z< - cos(x)
plot(x,y)
plot(x,z)
z< - cos(x)
z<- cos(x)
plot(x,z)
x <- seq(-2 * pi, 2 * pi, length.out = 1000)
y <- 2*sin(x)
z <- 4*sin(x)
plot(x,y) # sin wave
plot(x,z) #cos wave
z <- 4*sin(x)
plot(x,z) #cos wave
plot(x,y) # sin wave
plot(x,z) #cos wave
#question 4
#1
x <- seq(-2 * pi, 2 * pi, length.out = 1000)
y <- sin(x)
z <- cos(x)
plot(x,y) # sin wave
#3
y <- cos(2*x)
z <- cos(4*x)
plot(x,y)
plot(x,z)
#4
y <- cos(x + pi/4)
z <- cos(x + pi/2)
plot(x,y) #squished
plot(x,z)
plot(x,y) #squished
plot(x,z)
#1
y <- sin(x)
z <- cos(x)
plot(x,y) # sin wave
plot(x,z) #cos wave
#4
y <- cos(x + pi/4)
z <- cos(x + pi/2)
plot(x,y) #squished
#4
y <- cos(x + (pi/4))
z <- cos(x + (pi/2))
plot(x,y) #squished
plot(x,z)
plot(x,y) #squished
# Define the Monod growth function
monod_growth <- function(N, a, k) {
return((a * N) / (k + N))
}
# Generate a range of N values
N <- seq(0, 20, by = 0.1)
# Define the parameters for each curve
parameters <- list(
list(a = 5, k = 1),
list(a = 5, k = 3),
list(a = 8, k = 1)
)
# Set up the plot
plot(N, monod_growth(N, parameters[[1]]$a, parameters[[1]]$k),
type = "l", col = "blue", lwd = 2, ylim = c(0, 10),
xlab = "N (Nutrient Concentration)", ylab = "r(N) (Growth Rate)",
main = "Monod Growth Function")
# Add the other curves
lines(N, monod_growth(N, parameters[[2]]$a, parameters[[2]]$k), col = "red", lwd = 2)
lines(N, monod_growth(N, parameters[[3]]$a, parameters[[3]]$k), col = "green", lwd = 2)
# Add a legend
legend("bottomright", legend = c("a=5, k=1", "a=5, k=3", "a=8, k=1"),
col = c("blue", "red", "green"), lty = 1, lwd = 2)
