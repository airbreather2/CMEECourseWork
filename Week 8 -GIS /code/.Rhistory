segments(x0=(mean(y)), y0=(0), x1=(mean(y)), y1=40, lty=1, col="blue")
rm(list=ls())
require(WebPower)
?webpower
?WebPower
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
length(x)
plot(hist(y, breaks=10))
mean(y)
sd(y)
segments(x0=(mean(y)), y0=(0), x1=(mean(y)), y1=40, lty=1, col="blue")
# and now 0.25 sd left of the mean (because females are larger)
segments(x0=(mean(y)+0.25*sd(y)), y0=(0), x1=(mean(y)+0.25*sd(y)), y1=40, lty
=1, col="red")
?wp.t
wp.t(d=0.25, power=0.8, type="two.sample", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
res.1
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
res.1
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample
", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample", alternative="two.sided")
res.1
wp.t(d=0.25, power=0.8, type="two.sample", alternative="two.sided") #default two sided test needs to be run because not enough data
plot(res.1, xvar='n1', yvar='power')
plot(res.1, xvar='n1', yvar='power')
plot(res.1, xvar='n1', yvar='n2')
plot(res.1, xvar='n1', yvar='n2')
plot(res.1)
rm(list=ls())
x<-seq(from = -5, to = 5, by = 1)
x
## [1] 3
x[[length(x)]]
x<-seq(from = -5, to = 5, by = 1)
x
a<-2 #intercept
b<-1 #slope
y<-a+b*x
plot(x,y)
segments(0,-10,0,10, lty=3) #add axes
segments(-10,0,10,0,lty=3)
plot(x,y)
segments(0,-10,0,10, lty=3) #add axes
segments(-10,0,10,0,lty=3)
?abline
plot(x,y, col="white")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
abline(a = 2, b=1)
plot(x,y, col="green")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
plot(x,y, col="black")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
abline(a = 2, b=1)
points(4,0, col="red", pch=19)
points(-2,6, col="green", pch=9)
points(x,y, pch=c(1,2,3,4,5,6,7,8,9,10,11))
y<-x^2
plot(x,y)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
segments(0,-40,0,30, lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,20,30,0,lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(-30,0,30,0,lty=3)
segments(0,-30,0,30, lty=3)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
segments(0,-5,0,30, lty=3)
segments(0,-5,0,5, lty=3)
segments(0,-5,0,3, lty=3)
segments(0,-3,0,3, lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-3,0,3, lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-3,0,3, lty=3)
segments(0,-30,0,30, lty=3)
y<-x^2
plot(x,y)
segments(-3,0,3,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
#give linear function intercept of a-2
x<-seq(from = -5, to = 5, by = 0.1)
a<- -2
y<-a+x^2
plot(x,y)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
plot(x,y)
a<- -2
b<-3
y<-a+b*x^2
points(x,y, pch=19, col="red")
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
y<-a+b*x^2 #gave the curve a higher slope
points(x,y, pch=19, col="red")
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
plot(x,y)
a<- -2
b1<- 10
b2<-3
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(-100,0,100,0,lty=3)
plot(x,y)
a<- 1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(-100,0,100,0,lty=3)
plot(x,y)
a<- 1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
x<-seq(from = -100, to = 100, by = 1)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
text(highest_x, highest_y, labels=paste("Max y =", round(highest_y, 2)), pos=3)
#find highest y point in equation
x<-seq(from = -100, to = 100, by = 1)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
text(highest_x, highest_y, labels=paste("Max y =", round(highest_y, 2)), pos=3) # pos=3 places the text above the point for better visibility
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
#Local paralellisation
#run tasks in parallel for greater speed/efficiency
n <- 10000 #number of observations
data <- data.frane(
ID = sample(1:10, n, replace = TRUE), # ID column to define 10 groups
Y = rnorm(n), #creates a vector of 10000 random values from normal standard dist (mean=0,sd=1)
x = rnorm(n)
)
data <- data.frame(
ID = sample(1:10, n, replace = TRUE), # ID column to define 10 groups
Y = rnorm(n), #creates a vector of 10000 random values from normal standard dist (mean=0,sd=1)
x = rnorm(n)
)
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
View(data_groups)
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
model <- lm(y ~ X, data = group_data)
coef_df <- as.data.frame(t(coef(model)))
coef_df$ID <- unique(group_data$ID)  # Add ID for reference
return(coef_df)
}
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting y using X
model <- lm(y ~ X, data = group_data)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting y using X
model <- lm(y ~ X, data = data_groups)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting Y using x
model <- lm(Y ~ x, data = group_data)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
# Now, run the parallel code to fit models for each group
library(parallel)
num_cores <- detectCores() - 1  # Use all cores but one
# Use mclapply to run the fit_model function on each subset of the data
results <- mclapply(data_groups, fit_model, mc.cores = num_cores)
# Bind all the results into one data frame
final_results <- bind_rows(results)
print(final_results)
# make two simple `sfc` objects containing points in  the
# lower left and top right of the two grids
uk_pts_WGS84 <- st_sfc(st_point(c(-11, 49.5)), st_point(c(2, 59)), crs=4326)
uk_pts_BNG <- st_sfc(st_point(c(-2e5, 0)), st_point(c(7e5, 1e6)), crs=27700)
#  Use st_make_grid to quickly create a polygon grid with the right cellsize
uk_grid_WGS84 <- st_make_grid(uk_pts_WGS84, cellsize=0.5)
uk_grid_BNG <- st_make_grid(uk_pts_BNG, cellsize=1e5)
# Reproject BNG grid into WGS84
uk_grid_BNG_as_WGS84 <- st_transform(uk_grid_BNG, 4326)
# Plot the features
par(mar=c(0,0,0,0))
plot(uk_grid_WGS84, asp=1, border='grey', xlim=c(-13,4))
plot(st_geometry(uk_eire_sf), add=TRUE, border='darkgreen', lwd=2)
plot(uk_grid_BNG_as_WGS84, border='red', add=TRUE)
# Create the target raster
uk_raster_BNG <- rast(xmin=-200000, xmax=700000, ymin=0, ymax=1000000,
res=100000, crs='+init=EPSG:27700')
uk_raster_BNG_interp <- project(uk_raster_WGS84, uk_raster_BNG, method='bilinear')
uk_raster_BNG_near <- project(uk_raster_WGS84, uk_raster_BNG, method='near')
# Plotting the data reveals missing values in the top corners.
setwd("~/Documents/Ecological and evolutionary data/GIS WEEK 1 /code")
source("~/Documents/Ecological and evolutionary data/GIS WEEK 1 /code/practical1.R")
# make two simple `sfc` objects containing points in  the
# lower left and top right of the two grids
uk_pts_WGS84 <- st_sfc(st_point(c(-11, 49.5)), st_point(c(2, 59)), crs=4326)
uk_pts_BNG <- st_sfc(st_point(c(-2e5, 0)), st_point(c(7e5, 1e6)), crs=27700)
#  Use st_make_grid to quickly create a polygon grid with the right cellsize
uk_grid_WGS84 <- st_make_grid(uk_pts_WGS84, cellsize=0.5)
uk_grid_BNG <- st_make_grid(uk_pts_BNG, cellsize=1e5)
# Reproject BNG grid into WGS84
uk_grid_BNG_as_WGS84 <- st_transform(uk_grid_BNG, 4326)
# Plot the features
par(mar=c(0,0,0,0))
plot(uk_grid_WGS84, asp=1, border='grey', xlim=c(-13,4))
plot(st_geometry(uk_eire_sf), add=TRUE, border='darkgreen', lwd=2)
plot(uk_grid_BNG_as_WGS84, border='red', add=TRUE)
# Create the target raster
uk_raster_BNG <- rast(xmin=-200000, xmax=700000, ymin=0, ymax=1000000,
res=100000, crs='+init=EPSG:27700')
uk_raster_BNG_interp <- project(uk_raster_WGS84, uk_raster_BNG, method='bilinear')
uk_raster_BNG_near <- project(uk_raster_WGS84, uk_raster_BNG, method='near')
# Create the target raster
uk_raster_BNG <- rast(xmin=-200000, xmax=700000, ymin=0, ymax=1000000,
res=100000, crs='+init=EPSG:27700')
uk_raster_BNG_interp <- project(uk_raster_WGS84, uk_raster_BNG, method='bilinear')
uk_raster_BNG_near <- project(uk_raster_WGS84, uk_raster_BNG, method='near')
# Create the target raster
# Create a raster in the British National Grid (BNG) projection
uk_raster_BNG <- rast(
xmin = -200000,     # Minimum x-coordinate of the raster extent
xmax = 700000,      # Maximum x-coordinate of the raster extent
ymin = 0,           # Minimum y-coordinate of the raster extent
ymax = 1000000,     # Maximum y-coordinate of the raster extent
res = 100000,       # Resolution: each cell is 100,000 x 100,000 units
crs = '+init=EPSG:27700' # Coordinate Reference System: EPSG:27700 (BNG)
)
# Reproject a raster from WGS84 to BNG using bilinear interpolation
uk_raster_BNG_interp <- project(
uk_raster_WGS84,    # Source raster in WGS84 (EPSG:4326)
uk_raster_BNG,      # Target raster defining the extent and CRS
method = 'bilinear' # Interpolation method: bilinear for smooth values
)
# Reproject a raster from WGS84 to BNG using nearest-neighbor interpolation
uk_raster_BNG_near <- project(
uk_raster_WGS84,    # Source raster in WGS84 (EPSG:4326)
uk_raster_BNG,      # Target raster defining the extent and CRS
method = 'near'     # Interpolation method: nearest neighbor for categorical data
)
par(mfrow=c(1,2), mar=c(0,0,0,0))
plot(uk_raster_BNG_interp, main='Interpolated', axes=FALSE, legend=FALSE)
text(uk_raster_BNG_interp, digit=1)
plot(uk_raster_BNG_near, main='Nearest Neighbour',axes=FALSE, legend=FALSE)
text(uk_raster_BNG_near)
par(mfrow=c(1,2), mar=c(0,0,0,0))
plot(uk_raster_BNG_interp, main='Interpolated', axes=FALSE, legend=FALSE)
text(uk_raster_BNG_interp, digit=1)
plot(uk_raster_BNG_near, main='Nearest Neighbour',axes=FALSE, legend=FALSE)
text(uk_raster_BNG_near)
par(mfrow=c(1,2), mar=c(0,0,0,0))
plot(uk_raster_BNG_interp, main='Interpolated', axes=FALSE, legend=FALSE)
text(uk_raster_BNG_interp, digit=1)
plot(uk_raster_BNG_near, main='Nearest Neighbour',axes=FALSE, legend=FALSE)
text(uk_raster_BNG_near)
# make two simple `sfc` objects containing points in  the
# lower left and top right of the two grids
uk_pts_WGS84 <- st_sfc(st_point(c(-11, 49.5)), st_point(c(2, 59)), crs=4326)
uk_pts_BNG <- st_sfc(st_point(c(-2e5, 0)), st_point(c(7e5, 1e6)), crs=27700)
#  Use st_make_grid to quickly create a polygon grid with the right cellsize
uk_grid_WGS84 <- st_make_grid(uk_pts_WGS84, cellsize=0.5)
uk_grid_BNG <- st_make_grid(uk_pts_BNG, cellsize=1e5)
# Reproject BNG grid into WGS84
uk_grid_BNG_as_WGS84 <- st_transform(uk_grid_BNG, 4326)
# Plot the features
par(mar=c(0,0,0,0))
plot(uk_grid_WGS84, asp=1, border='grey', xlim=c(-13,4))
plot(st_geometry(uk_eire_sf), add=TRUE, border='darkgreen', lwd=2)
plot(uk_grid_BNG_as_WGS84, border='red', add=TRUE)
# Create the target raster
# Create a raster in the British National Grid (BNG) projection
uk_raster_BNG <- rast(
xmin = -200000,     # Minimum x-coordinate of the raster extent
xmax = 700000,      # Maximum x-coordinate of the raster extent
ymin = 0,           # Minimum y-coordinate of the raster extent
ymax = 1000000,     # Maximum y-coordinate of the raster extent
res = 100000,       # Resolution: each cell is 100,000 x 100,000 units
crs = '+init=EPSG:27700' # Coordinate Reference System: EPSG:27700 (BNG)
)
# Reproject a raster from WGS84 to BNG using bilinear interpolation
uk_raster_BNG_interp <- project(
uk_raster_WGS84,    # Source raster in WGS84 (EPSG:4326)
uk_raster_BNG,      # Target raster defining the extent and CRS
method = 'bilinear' # Interpolation method: bilinear for smooth values
)
# Reproject a raster from WGS84 to BNG using nearest-neighbor interpolation
uk_raster_BNG_near <- project(
uk_raster_WGS84,    # Source raster in WGS84 (EPSG:4326)
uk_raster_BNG,      # Target raster defining the extent and CRS
method = 'near'     # Interpolation method: nearest neighbor for categorical data
)
par(mfrow=c(1,2), mar=c(0,0,0,0))
plot(uk_raster_BNG_interp, main='Interpolated', axes=FALSE, legend=FALSE)
text(uk_raster_BNG_interp, digit=1)
plot(uk_raster_BNG_near, main='Nearest Neighbour',axes=FALSE, legend=FALSE)
text(uk_raster_BNG_near)
# Create the target raster grid with 20 km resolution
uk_20km <- rast(
xmin = -200000,       # Minimum x-coordinate of the raster extent
xmax = 650000,        # Maximum x-coordinate of the raster extent
ymin = 0,             # Minimum y-coordinate of the raster extent
ymax = 1000000,       # Maximum y-coordinate of the raster extent
res = 20000,          # Resolution: each cell is 20,000 x 20,000 units
crs = '+init=EPSG:27700' # Coordinate Reference System: British National Grid (EPSG:27700)
)
# Rasterize the polygons from `uk_eire_BNG` into the 20 km raster grid
# Assign cell values based on the 'name' attribute of the polygons
uk_eire_poly_20km <- rasterize(
uk_eire_BNG,          # Input polygon data (e.g., UK and Ireland boundaries)
uk_20km,              # Target raster grid
field = 'name'        # Attribute to assign to raster cells (e.g., region names)
)
# Plot the rasterized polygons
plot(uk_eire_poly_20km)
# - Convert the 'name' attribute to a factor for categorical rasterization
uk_eire_BNG$name <- as.factor(uk_eire_BNG$name)
# - Set attributes as constant to suppress sf warnings when altering geometries
st_agr(uk_eire_BNG) <- 'constant'
# - Rasterizing boundary lines:
#   - Convert polygons to LINESTRING geometry
uk_eire_BNG_line <- st_cast(uk_eire_BNG, 'LINESTRING')
#   - Rasterize the LINESTRING geometries
uk_eire_line_20km <- rasterize(uk_eire_BNG_line, uk_20km, field='name')
# - Rasterizing points:
#   - Two-step casting: Polygon -> Multipoint -> Point
uk_eire_BNG_point <- st_cast(st_cast(uk_eire_BNG, 'MULTIPOINT'), 'POINT')
#   - Rasterize the POINT geometries
uk_eire_point_20km <- rasterize(uk_eire_BNG_point, uk_20km, field='name')
# - Define a color palette for plotting
color_palette <- hcl.colors(6, palette = 'viridis', alpha = 0.5)
# - Plot the different rasterized outcomes side by side
par(mfrow = c(1, 3), mar = c(1, 1, 1, 1)) # Set up a 1x3 plotting layout
# - Plot rasterized polygons and overlay original polygon geometry in red
plot(uk_eire_poly_20km, col = color_palette, legend = FALSE, axes = FALSE)
plot(st_geometry(uk_eire_BNG), add = TRUE, border = 'red')
# - Plot rasterized boundary lines and overlay original polygon geometry in red
plot(uk_eire_line_20km, col = color_palette, legend = FALSE, axes = FALSE)
plot(st_geometry(uk_eire_BNG), add = TRUE, border = 'red')
# - Plot rasterized points and overlay original polygon geometry in red
plot(uk_eire_point_20km, col = color_palette, legend = FALSE, axes = FALSE)
plot(st_geometry(uk_eire_BNG), add = TRUE, border = 'red')
source("~/Documents/Ecological and evolutionary data/GIS WEEK 1 /code/practical1.R")
# - Rasterizing boundary lines:
#   - Convert polygons to LINESTRING geometry
uk_eire_BNG_line <- st_cast(uk_eire_BNG, 'LINESTRING')
#   - Rasterize the LINESTRING geometries
uk_eire_line_20km <- rasterize(uk_eire_BNG_line, uk_20km, field='name')
# - Rasterizing points:
#   - Two-step casting: Polygon -> Multipoint -> Point
uk_eire_BNG_point <- st_cast(st_cast(uk_eire_BNG, 'MULTIPOINT'), 'POINT')
#   - Rasterize the POINT geometries
uk_eire_point_20km <- rasterize(uk_eire_BNG_point, uk_20km, field='name')
# - Define a color palette for plotting
color_palette <- hcl.colors(6, palette = 'viridis', alpha = 0.5)
# - Plot the different rasterized outcomes side by side
par(mfrow = c(1, 3), mar = c(1, 1, 1, 1)) # Set up a 1x3 plotting layout
# - Plot rasterized polygons and overlay original polygon geometry in red
plot(uk_eire_poly_20km, col = color_palette, legend = FALSE, axes = FALSE)
plot(st_geometry(uk_eire_BNG), add = TRUE, border = 'red')
# - Plot rasterized boundary lines and overlay original polygon geometry in red
plot(uk_eire_line_20km, col = color_palette, legend = FALSE, axes = FALSE)
plot(st_geometry(uk_eire_BNG), add = TRUE, border = 'red')
# - Plot rasterized points and overlay original polygon geometry in red
plot(uk_eire_point_20km, col = color_palette, legend = FALSE, axes = FALSE)
plot(st_geometry(uk_eire_BNG), add = TRUE, border = 'red')
# Note the differences between polygon and line rasterization:
# Note the differences between polygon and line rasterization:
# - Polygons: A cell is included only if its center falls within the polygon.
# - This explains why coastal cells under the border may be missing in the
# - This explains why coastal cells under the border may be missing in the
#   polygon raster but are included in the line raster. Coastal cells' centers
